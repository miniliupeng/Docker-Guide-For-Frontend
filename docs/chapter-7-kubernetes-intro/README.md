# 第七章：初探容器编排 - Kubernetes 入门

## 7.1 本章目标

欢迎来到我们教程的全新章节！在前六章中，我们已经彻底掌握了如何为前端应用构建、优化、测试和自动化部署 Docker 镜像。我们学会了使用 Docker Compose 在**单台主机**上管理多个容器。

然而，当应用规模变得更大，需要跨越多台服务器部署，并要求高可用、自动扩缩容时，Docker Compose 就显得力不从心了。这时，我们就需要一个更强大的工具——**Kubernetes (K8s)**。

本章的目标不是让你成为 Kubernetes 专家，而是为你打开一扇通往**大规模容器编排**世界的大门。完成本章后，你将能够：

-   **理解为什么需要 Kubernetes**：它解决了什么 Docker Compose 解决不了的问题。
-   **掌握 Kubernetes 的核心概念**：用清晰的类比理解 Pod, Service, Deployment 等“行话”。
-   **了解你的 Docker 镜像在 K8s 中的角色**：将我们之前的所有知识与 K8s 的世界观连接起来。
-   **明确前端开发者在云原生时代的角色**：知道自己需要懂什么，以及与 DevOps 团队协作的边界在哪里。

---

## 7.2 从 Docker Compose 到 Kubernetes：为什么需要 K8s？

我们可以将 Docker Compose 想象成一个“**单机游戏**”，它非常擅长在你的笔记本电脑或一台独立的服务器上，管理一组互相连接的容器。

但当游戏升级到“**大型多人在线网络游戏 (MMO)**”时，我们就需要 Kubernetes 了。

| 场景 | Docker Compose (单机游戏) | Kubernetes (大型网游) |
| :--- | :--- | :--- |
| **服务器规模** | 只能管理**一台**主机上的容器。 | 能同时管理**成百上千台**主机（称为“集群”）上的容器。 |
| **高可用性** | 如果你的主机宕机了，所有服务就都中断了。 | 如果集群中的某一台主机宕机，K8s 会**自动**在其他健康的机器上重新启动受影响的容器，服务不中断。这叫**自愈 (Self-healing)**。 |
| **扩缩容** | 需要手动修改 `docker-compose.yml` 并重启服务。 | 可以根据 CPU 或内存使用率，**自动**增加或减少容器的副本数量，轻松应对流量高峰。这叫**自动扩缩容 (Auto-scaling)**。 |
| **服务发现** | 依赖于 Docker Engine 的内部 DNS，仅限于单机。 | 拥有更强大、更复杂的网络模型，可以在整个集群范围内实现可靠的服务发现和负载均衡。 |
| **滚动更新** | 支持滚动更新，但功能相对基础。 | 提供复杂的部署策略，如**滚动更新 (Rolling Update)**、**蓝绿部署 (Blue-Green Deployment)**、**金丝雀发布 (Canary Release)**，确保应用更新过程平滑、无中断，且易于回滚。 |

**一句话总结**：`docker compose` 是优秀的**开发和单机部署工具**，而 Kubernetes 是**生产环境大规模容器化应用的事实标准**。

## 7.3 K8s 核心概念速览 (万米高空视角)

Kubernetes 的概念体系非常庞大，但作为前端开发者，我们只需要从一个较高的层次理解几个核心“角色”即可。我们可以把一个 K8s 集群想象成一个自动化的“**微缩城市**”。

-   **集群 (Cluster)** 🏙️
    -   **是什么**：整个“城市”本身，由多台物理机或虚拟机组成。
    -   **类比**：一个完整的、自给自足的城市。

-   **节点 (Node)** 🏭
    -   **是什么**：集群中的一台机器（物理机或虚拟机）。
    -   **类比**：城市里的一个“**功能区**”或“**建筑**”，比如工业区或居民楼，负责实际运行程序。

-   **Pod** 🏠
    -   **是什么**：Kubernetes 中**最小的部署单元**。一个 Pod 里可以包含一个或多个紧密相关的容器。
    -   **类比**：城市建筑里的一个“**公寓套间**”。这个套间可以直接入住我们之前构建的 `frontend` 容器。所有住在同一个套间里的容器，共享网络和存储，就像一家人一样。

-   **Deployment (部署)** 📝
    -   **是什么**：一个“**管理蓝图**”，它定义了我们希望一个应用（例如 `frontend`）保持什么样的状态。
    -   **类比**：城市规划局的“**建筑规章**”。这份规章写着：“A 小区必须**始终保持有 3 间**一模一样的‘前端公寓’(Pod) 在正常运营。如果有一间因为地震（机器宕机）倒塌了，必须立刻在其他地方重建一间新的。” 它负责维护 Pod 的数量和应用的更新。

-   **Service (服务)** 📮
    -   **是什么**：为一组功能相同的 Pod 提供一个**稳定不变的访问入口**。
    -   **类比**：一个“**小区的物业收发室**”。小区的公寓可能会因为维修而改变房间号（Pod 的 IP 地址会变），但“A 小区收发室”这个地址是永远不变的。后端服务想给前端发消息，只需要寄到这个“收发室”，物业（Service）会自动帮你把信送到当前一个健康的公寓里。它解决了 Pod 动态变化带来的通信难题。

-   **Ingress (入口)** 🚪
    -   **是什么**：管理**集群外部流量**如何访问集群内部服务的规则集合。
    -   **类比**：整个城市的“**主入口/海关**”。它根据访客的域名（如 `app.mycompany.com`）或 URL 路径（如 `/api`），决定将他们引导到哪个小区的“收发室”（哪个 Service）。

**流程总结**：

> 你（开发者）写了一份 **Deployment**（建筑规章），要求 K8s 启动 3 个包含你前端镜像的 **Pod**（公寓）。K8s 会在不同的 **Node**（建筑）上创建这些 Pod。然后，你创建了一个 **Service**（物业收发室），为这 3 个 Pod 提供了一个统一的内部地址。最后，你配置了一个 **Ingress**（城市主入口），告诉全世界，访问 `app.mycompany.com` 的流量，都应该被送到这个“前端物业收发室”。

## 7.4 你的 Docker 镜像在 K8s 中的旅程

现在，我们可以把整个教程的所有知识点串联起来了。

1.  **编写 `Dockerfile`** (第二、三章)
    -   你精心编写了一个多阶段构建的 `Dockerfile`，产出一个轻量、安全的 Nginx 静态服务器镜像。

2.  **构建并推送镜像** (第二、六章)
    -   你使用 `docker build` (或通过 CI/CD) 构建了这个镜像，并将其推送到了一个镜像仓库（如 Docker Hub）。这是**将你的代码“上交”给云原生世界的唯一方式**。

3.  **编写 Kubernetes YAML 文件** (本章)
    -   DevOps 工程师会编写一个 `deployment.yaml` 文件。在这个文件里，最核心的一行是：
        ```yaml
        spec:
          template:
            spec:
              containers:
              - name: frontend-container
                image: your-dockerhub-username/my-frontend-app:latest # 看！这里用到了你推送的镜像！
        ```

4.  **应用到集群**
    -   DevOps 工程师执行 `kubectl apply -f deployment.yaml`。
    -   Kubernetes 收到指令，从 Docker Hub **拉取 (pull)** 你指定的镜像。
    -   然后，K8s 会按照这份“规章”，创建 Pod，并在其中运行你的镜像，启动一个容器。

**结论**：你在前六章学到的一切——**如何构建一个高质量、标准化的 Docker 镜像**——是整个云原生工作流的**基石和起点**。没有一个可靠的镜像，Kubernetes 就算有通天的本领，也无米下炊。

## 7.5 总结：前端开发者的 K8s 边界

读到这里，你可能会感到一丝不知所措，Kubernetes 似乎太复杂了。但好消息是：

> **作为一名前端开发者，你通常不需要亲自编写或维护复杂的 Kubernetes YAML 文件。**

这通常是 DevOps 团队或平台团队的职责。

你需要掌握的是：

1.  **交付高质量的镜像**：这是你的核心职责。一个优化良好、行为可预测的镜像是你与运维团队协作的最佳“接口”。
2.  **理解核心概念**：你需要听得懂 DevOps 团队在说什么。当他们提到 “Pod 重启”、“Service 不通”、“Ingress 规则”时，你能大致理解问题的范畴，从而更高效地进行协作和问题排查。
3.  **构建“云原生友好”的应用**：例如，学会如何让你的应用可以通过环境变量进行配置，如何处理容器发送的 `SIGTERM` 信号以实现优雅停机等。这些知识能让你的应用在 K8s 这类自动化环境中表现得更好。

本章的目的，就是为你建立起这份认知和沟通的桥梁。掌握了 Docker，又对 Kubernetes 有了宏观的认识，你就拥有了在现代云原生开发环境中乘风破浪的坚实基础。
